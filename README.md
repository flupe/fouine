# About this project.

[Second assignment](http://perso.ens-lyon.fr/daniel.hirschkoff/P2/) -- Lucas Escot & Romain Liautaud -- PROJ2 *(Daniel Hirschkoff, ENS de Lyon, 2017)*.

This project is an implementation of **fouine**, a toy programming language based on OCaml. It provides both an interpreter and a compiler, as well as the SECD machine to execute the compiled bytecode.

*A note on work sharing:*
- Lucas implemented the parser and interpreter, plus a few utilities *(e.g. pretty-printing)*.
- Romain implemented the compiler and the SECD machine.

Lucas also worked on type inference, and we split work on the transformations.

## Notable changes.

Since the first release of the project, we have done a considerable amount of refactoring and extension, including:
- Complete support of polymorphic exceptions by both the interpreter and the SECD machine.
- Introduction of tuples and lists.
- Type checking and pattern matching using Didier Rémy's extension of Algorithm W.
- Transition of all operators to meta-closures.
- Transformations.

## Usage.

> **Note**: We switched to `menhir` for parsing along the way. To compile properly, make sure you have it installed.
  
  ```
  opam install menhir
  ```

- Compile with `make`.

- Run with `./fouine` to launch a REPL.

  By default, the REPL will interpret the parsed expressions using the `Interpreter` module.

  If `rlwrap` is installed on your machine, the REPL will maintain a history of your previous inputs, which you can access using the `↑` and `↓` keys.

- Use option `-machine` to instead compile the parsed expression to a custom SECD bytecode using the `Compiler` module, and then run that bytecode using the `Secd` module.

- Use option `-interm file` to store the generated bytecode to the given file in binary format.
- Use option `-from file` to run the bytecode stored in the given file in binary format.
- Use option `-E` to apply the transformation which removes exceptions.
- Use option `-R` to apply the transformation which removes references.

- Add option `-debug` to get a pretty-printed version of the AST that was parsed, as well as the bytecode that was produced by the compiler *(when used in conjunction with the `-machine` option)*.

## Test suite.

The `tests/` directory contains a few code snippets which illustrate the capabilities of our implementation -- e.g. support of booleans, control flow operations, references, exceptions, recursive functions or integer arrays.

## Code structure.

As usual, the source files for our modules are located inside the `src` folder, while all the build files generated by `ocamlbuild` are added to the `_build` folder: this way we don't mix up the two.

- The lexing and parsing of **fouine** expressions is handled by `ocamllex` and `menhir`, which are configured using files `lexer.mll` and `parser.mly`. Once parsed, the expressions have type `Ast.t`.
- The `Interpreter`, `Compiler` and `Secd` modules do just what you would expect.
- The `Shared` and `Base` modules provide the types and functions that are shared between the interpreter and the SECD machine.
- The `Bytecode` module contains a specification of the bytecode shared between our compiler and SECD machine.
- The `Beautify` module provides pretty-printing utilities for all types of values *(integers, arrays, functions, etc.)*.
- The `Print` module provides text formatting utilities.
- The `Nbe` module is an experimental implementation of **normalization by evaluation**, which is not fully ready yet.


# Implementation details.

## General design choices.

- We provide atomic types `unit`, `int`, `bool`, `array`, `'a ref`, `fun`.
- We support tuples, lists, **and pattern matching on them**.
- We support polymorphic exceptions.
- We only support arrays of integers *(because the assignment asked us to do so -- we could actually provide arrays of anything, even heterogeneous arrays)*.
- We support references to any of the previous atomic types, including functions.
- We have decided that the `:=` operator should return `unit` to stay consistent with OCaml.

### About builtin functions.

In order to provide a systematic -- and somewhat more elegant -- way of dealing with builtin functions, such as `prInt`, `aMake` or `ref`, as well as all the operators, we have decided to consider them just like any other function, so there are no special tokens for them.

Then, instead of starting to execute the code on an empty environment, we pre-load all those functions in the environment with the special type `MetaClosure`. This way, we can do something like:

```ocaml
let f = prInt in f 2;;
```
## Parsing.

### Currently supported syntax.

- A delimiter `;;` is **required** at the end of a given input.
- Any integer constants (including negative numbers).
- Boolean constants: `true` and `false`.
- Integer arithmetic: `*`, `+`, `-`, ` ~-`, `/` and `mod`.
- Integer comparisons: `<`, `>`, `<=`, `>=`, `=`, `<>`.
- Boolean operations: `&&`, `||` and `not`.
- List operations: `::` and `@`.
- Named function declaration with multiple arguments with the `let` syntax.

  ```ocaml
  let f x y =
    x + 2 * y
  ```
- Anonymous function declaration with multiple arguments with the `fun` syntax.

  ```ocaml
  fun x y ->
    x + 2 * y
  ```
- Conditionnal statements: `if`, `then`, `else`.
  Note that, as in OCaml, a `else` branch is optional in which case a `unit` value is implied.

- Exception handling syntax: `try ... with E x -> ...`.
- Special `prInt` command to print integers, as well as `prOut` to print any type to standard out.
- Support for references: `ref 2`, `!x`, `x := 3`.
- Sequencing with `;`.
- Support for `int array` with `aMake` and the usual `arr.(i)` syntax.
- Chained function calls, even with anonymous functions.
- Scopes delimited by parens or `begin`, `end`.
- Support of several successive `let` statements without `;;` between them.
- **New !** : Full pattern matching in `let` bindings, function declarations and exceptions.

  ```ocaml
  >>> let x, (y, z) = 1, (2, 3);;
  - : (int * (int * int)) = (1, (2, 3))
  >>> x;;
  - : int = 1
  >>> y;;
  - : int = 2;;
  ```

  ```ocaml
  >>> let f (x, y) = x * y;;
  >>> f (1, 2);;
  - : int = 2
  ```

  ```ocaml
  >>> try
        raise (1, 2)
      with E (x, y) ->
        x + y
      ;;
  - : int = 3
  ```

## REPL.

When running `./fouine` without additionnal parameters, we provide a REPL *(read-eval-print-loop)*, meaning that you can do the following:

```ocaml
>>> let a = 3;;
- : int = 3
>>> let b = 4;;
- : int = 4
>>> a + b;;
- : int = 7
```

Our pretty-printing routine is designed to be as explicit as possible. For instance:
```ocaml
>>> aMake 5;;
- : int array = [| 0; 0; 0; 0; 0 |]
```

```ocaml
>>> prInt;;
- : builtin = -
```

More interestingly, when dealing with partially evaluated functions, we substitute the already bound variables with their values:
```ocaml
>>> let f x y = x * y;;
- : fun = fun x -> fun y ->
    x * y
>>> f 2;;
- : fun = fun y -> 2 * y
```

## Interpretation.

We support the following:
- All arithmetical and boolean operations.
- Control flow (`if`, `else`).
- Variable definition and fetching through environments.
- Closures and variable propagation.
- Function calls, currying.
- Full reference support.
- Integer array support.
- Builtin functions on a metalanguage level (`prInt`, `prOut`, `aMake`).
- Successive `let` definitions without the `in` keyword with a persistent global environment.
- Recursion.
- Exceptions handling.

## Compilation.

We support all of the above.

We use an extension of the SECD bytecode suggested in class, which has additionnal instructions to support conditonnal statements, recursive functions, arrays, exceptions or references.

```ocaml
type bytecode =
  instruction list

and instruction
  = BConst of Ast.constant
  | BTuple of int
  | BArraySet
  | BArrayRead
  | BAccess of identifier
  | BEncap of bytecode
  | BTry of pattern
  | BRaise
  | BClosure of pattern * bytecode
  | BRecClosure of identifier * pattern * bytecode
  | BLet of pattern
  | BEndLet
  | BApply
  | BBranch
  | BReturn
```