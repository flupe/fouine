# About this project.

[Second assignment](http://perso.ens-lyon.fr/daniel.hirschkoff/P2/) -- Lucas Escot & Romain Liautaud -- PROJ2 *(Daniel Hirschkoff, ENS de Lyon, 2017)*.

This project is an implementation of **fouine**, a toy programming language based on OCaml. It provides both an interpreter and a compiler, as well as the SECD machine to execute the compiled bytecode.

*A note on work sharing:*
- Lucas implemented the parser and interpreter, plus a few utilities *(e.g. pretty-printing)*.
- Romain implemented the compiler and the SECD machine.

Lucas also worked on type inference, and we split work on the transformations.

## Notable changes.

Since the first release of the project, we have done a considerable amount of refactoring and extension, including:
- Complete support of polymorphic exceptions by both the interpreter and the SECD machine.
- Introduction of tuples and lists.
- Type checking and pattern matching using Didier Rémy's extension of Algorithm W.
- Transition of all operators to meta-closures.
- Support of user-defined infix and prefix operators.
- Transformations *(almost)*.

## Usage.

> **Note**: We switched to `menhir` for parsing along the way. To compile properly, make sure you have it installed *(`opam install menhir`)*.

- Compile with `make`.

- Run with `./fouine` to launch a REPL.

  By default, the REPL will interpret the parsed expressions using the `Interpreter` module.

  If `rlwrap` is installed on your machine, the REPL will maintain a history of your previous inputs, which you can access using the `↑` and `↓` keys.

- Use option `-machine` to instead compile the parsed expression to a custom SECD bytecode using the `Compiler` module, and then run that bytecode using the `Secd` module.

- Use option `-interm file` to store the generated bytecode to the given file in binary format.
- Use option `-from file` to run the bytecode stored in the given file in binary format.
- Use option `-E` to apply the transformation which removes exceptions.
- Use option `-R` to apply the transformation which removes references.

- Add option `-debug` to get a pretty-printed version of the AST that was parsed, as well as the bytecode that was produced by the compiler *(when used in conjunction with the `-machine` option)*.

## Test suite.

The `tests/` directory contains a few code snippets which illustrate the capabilities of our implementation -- e.g. support of booleans, control flow operations, references, exceptions, recursive functions or integer arrays.

## Code structure.

As usual, the source files for our modules are located inside the `src` folder, while all the build files generated by `ocamlbuild` are added to the `_build` folder: this way we don't mix up the two.

- The lexing and parsing of **fouine** expressions is handled by `ocamllex` and `menhir`, which are configured using files `lexer.mll` and `parser.mly`. Once parsed, the expressions have type `Ast.t`.
- The `Interpreter`, `Compiler` and `Secd` modules do just what you would expect.
- The `Shared` and `Base` modules provide the types and functions that are shared between the interpreter and the SECD machine.
- The `Bytecode` module contains a specification of the bytecode shared between our compiler and SECD machine.
- The `Beautify` module provides pretty-printing utilities for all types of values *(integers, arrays, functions, etc.)*.
- The `Print` module provides text formatting utilities.
- The `Nbe` module is an experimental implementation of **normalization by evaluation**, which is not fully ready yet.


# Implementation details.

## General design choices.

- We provide atomic types `unit`, `int`, `bool`, `array`, `'a ref`, `fun`.
- We support tuples **and pattern matching on them**.
- We support building lists with the `::` consing operator.
- We support polymorphic exceptions.
- We only support arrays of integers *(because the assignment asked us to do so -- we could actually provide arrays of anything, even heterogeneous arrays)*.
- We support references to any of the previous atomic types, including functions.
- We have decided that the `:=` operator should return `unit` to stay consistent with OCaml.

### About builtin functions.

In order to provide a systematic -- and somewhat more elegant -- way of dealing with builtin functions, such as `prInt`, `aMake` or `ref`, as well as all the operators, we have decided to consider them just like any other function, so there are no special tokens for them.

Then, instead of starting to execute the code on an empty environment, we pre-load all those functions in the environment with the special type `MetaClosure`. This way, we can do something like:

```ocaml
let f = prInt in f 2;;
```

### Type inference.

A complete Hindley-Milner type system has been implemented with type inference. The latter is based on work from Didier Rémy for the OCaml compiler. As with OCaml, `let` bindings introduce quantifiers to unbound types, yet we never generalize mutable objects to ensure soundness.

This way, usual pitfalls associated with mutable containers are systematically avoided:

```ocaml
>>> let a = ref [];;
val a : ('_b list) ref = { contents = [] }
>>> 1 :: !a;;
- : int list = [1]
>>> a;;
- : (int list) ref = { contents = [] }
```

```ocaml
>>> let a = ref (fun x -> x);;
val a : ('_b -> '_b) ref = { contents = <fun> }
>>> a := fun x -> x + 1;;
- : unit = ()
>>> a;;
- : (int -> int) ref = { contents = <fun> }
```

### Type constraints.

It is possible to restrict the type of an expression by explicitely specifying it, using the dedicated `(expr : type)` syntax. Parens are required.

```ocaml
>>> (fun x -> x : int -> int);;
- : int -> int = <fun>
```

### Union types.

For the last submission, we added the ability to define user-land recursive union types. Just as in OCaml, these types can be polymorphic and parametrized by multiple type variables.

```ocaml
>>> type 'a ok = Machin of 'a | Truc of int;;
>>> Truc 5;;
- : '_a ok = Truc (5)
>>> Machin [true; false];;
- : bool list ok = Machin ((::) (true, (::) (false, [])))

>>> type ('a, 'b) pair = Left of 'a | Right of 'b;;
>>> Right 5;;
- : ('_a, int) pair = Right (5)

>>> type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree;;
>>> Leaf;;
- : '_a tree = Leaf
>>> Node (1, Leaf, Node (5, Leaf, Leaf));;
- : int tree = Node (1, Leaf, Node (5, Leaf, Leaf))
```

In hope of making these types useful, pattern-matching was extended to allow matching on constructors:

```ocaml
>>> type 'a ok = Machin of 'a;;
>>> let a = Machin 3;;
val a : int ok = Machin (3)
>>> let Machin b = a;;
val b : int = 3
```

Fun fact, in OCaml the tokens `[]` and `(::)` are special constructors, and `[1; 3; 4]` and `1 :: []` is merely syntaxic sugar to make everything practical. Thus `[1; 2]` is strictly equivalent to `(::) (1, (::) (2, []))`.
Because we thought it would be thrilling (really, it isn't), we chose to implement lists in *fouine* as regular *fouine* constructors, making the three following expressions equivalent:

```ocaml
>>> [1; 2; 3];;
>>> 1 :: 2 :: 3 :: [];;
>>> (::) (1, (::) (2, (::) (3, [])));;
```

Like other constructors, pattern matching is possible, with added sweetness:

```ocaml
>>> let l = [1; 2; 3];;
>>> let (::) (h, t) = l;;
>>> let h :: t = l;;
val h : int = 1
val t : int list = (::) (2, (::) (3, []))
```

You are free to rebind these two constructors as you wish, also this is definitely a very poor practice.

```ocaml
>>> type 'a truc = [] | (::) of 'a truc * 'a;;
>>> ([] :: 1) :: 2;;
- : int truc = (::) ((::) ([], 1), 2)
```

Finally, in OCaml, there is a subtle difference between `type ok = Machin of int * int` and `type ok = Machin of (int * int)`. In the first type definition, `Machin` is a constructor expecting 2 arguments of type `int`, whereas in the latter it requires only 1 argument of type `int * int`.
The difference is often experienced during pattern matching:

```ocaml
# type ok = Machin of (int * int);;
# let a = Machin (2, 5);;
# let Machin b = a;;
val b : int * int = (2, 5)
```

```ocaml
# type ok = Machin of int * int;;
# let a = Machin (2, 5);;
# let Machin b = a;;
Error: The Constructor Machin expects 2 argument(s), but it is applied here to 1 argument(s).
```

In our *fouine* interpreter, this difference is taken into account (It fails miserably in the second example, as wanted, showing a cryptic error message).

### Type aliases.

It is now also possible to define type aliases. They are really only useful when constraining the type of an expression. Sadly we do not explicitely tell an expression belongs to some given type alias, even if its type has been restricted accordingly.

```ocaml
>>> type liste = int list;;
>>> ([] : liste);;
- : int list = []
```

### Exceptions.

```ocaml
type exn = E of int;;
```

Now that we have union types in *fouine* we can define `E` as regular *fouine* constructor of the sum type `exn`.
This makes the parser a tad simpler, and allows the manipulation of exceptions as first-class *fouine* components.
It also makes it possible to specify `raise` as a function expecting an argument of type `exn` in the type inference pass.

```ocaml
try
  let x = E 5 in
  raise x
with E x ->
  print_endline "caught exception :";
  x
```

## Parsing.

### Currently supported syntax.

- A delimiter `;;` is **required** at the end of a given input.
- Any integer constants (including negative numbers).
- Boolean constants: `true` and `false`.
- Integer arithmetic: `*`, `+`, `-`, ` ~-`, `/` and `mod`.
- Integer comparisons: `<`, `>`, `<=`, `>=`, `=`, `<>`.
- Boolean operations: `&&`, `||` and `not`.
- List operations: `::` and `@`.
- Also `|>` and `@@`.
- Named function declaration with multiple arguments with the `let` syntax.

  ```ocaml
  let f x y =
    x + 2 * y
  ```
- Anonymous function declaration with multiple arguments with the `fun` syntax.

  ```ocaml
  fun x y ->
    x + 2 * y
  ```
- Conditionnal statements: `if`, `then`, `else`.
  Note that, as in OCaml, a `else` branch is optional in which case a `unit` value is implied.

- Exception handling syntax: `try ... with E x -> ...`.
- Special `prInt` command to print integers, as well as `prOut` to print any type to standard out.
- Support for references: `ref 2`, `!x`, `x := 3`.
- Sequencing with `;`.
- Support for `int array` with `aMake` and the usual `arr.(i)` syntax.
- Chained function calls, even with anonymous functions.
- Scopes delimited by parens or `begin`, `end`.
- Support of several successive `let` statements without `;;` between them.
- **New!** : Full pattern matching in `let` bindings, function declarations and exceptions.

  ```ocaml
  >>> let x, (y, z) = 1, (2, 3);;
  val x : int = 1
  val y : int = 2
  val z : int = 3
  ```

  ```ocaml
  >>> let f (x, y) = x * y;;
  >>> f (1, 2);;
  - : int = 2
  ```

## REPL.

When running `./fouine` without additionnal parameters, we provide a REPL *(read-eval-print-loop)*, meaning that you can do the following:

```ocaml
>>> let a = 3;;
val a : int = 3
>>> let b = 4;;
val b : int = 4
>>> a + b;;
- : int = 7
```

Our pretty-printing routine is designed to be as explicit as possible. For instance:
```ocaml
>>> aMake 5;;
- : int array = [| 0; 0; 0; 0; 0 |]
```

```ocaml
>>> prInt;;
- : int -> int = <fun>
```

## Interpretation.

We support the following:
- All arithmetical and boolean operations.
- Control flow (`if`, `else`).
- Variable definition and fetching through environments.
- Closures and variable propagation.
- Function calls, currying.
- Full reference support.
- Integer array support.
- Builtin functions on a metalanguage level (`prInt`, `prOut`, `aMake`).
- Successive `let` definitions without the `in` keyword with a persistent global environment.
- Recursion.
- Exceptions handling.
- Pattern matching. Every parameter of a function is a pattern. Same goes for the left-hand side of every `let` binding other than a function definition.


## AST Transformations.

### CPS Transform.
Running the executable with the `-E` option processes the AST to handle exceptions via continuations while removing them altogether from the AST. This transform is now **applicable to any fouine expression**, even recursive definitions (without the need for additional constructors such as `Fix`).

We hit a roadblock when trying to support builtin binary operators, as any function now takes two new arguments yet binary operators are curryfied meaning you can't simply add arguments to the uppermost level. But soon a hackish solution was found: We are able to find out how many arguments a function expects by looking at its type in the type environment (`TArrow(-, TArrow(-, -))`), and apply recursively the transformation. This is done once on the default environment.

## Compilation.

We support all of the above.

We use an extension of the SECD bytecode suggested in class, which has additionnal instructions to support conditonnal statements, recursive functions, arrays, exceptions or references.

```ocaml
type bytecode =
  instruction list

and instruction
  = BConst of Ast.constant
  | BTuple of int
  | BArraySet
  | BArrayRead
  | BAccess of identifier
  | BEncap of bytecode
  | BTry of pattern
  | BRaise
  | BClosure of pattern * bytecode
  | BRecClosure of identifier * pattern * bytecode
  | BLet of pattern
  | BEndLet
  | BApply
  | BBranch
  | BReturn
```
