# About this project.

[Second assignment](http://perso.ens-lyon.fr/daniel.hirschkoff/P2/) -- Lucas Escot & Romain Liautaud -- PROJ2 *(Daniel Hirschkoff, ENS de Lyon, 2017)*.

This project is an implementation of **fouine**, a toy programming language based on OCaml. It provides both an interpreter and a compiler, as well as the SECD machine to execute the compiled bytecode.

*A note on work sharing:*
- Lucas implemented the parser and interpreter, plus a few utilities *(e.g. pretty-printing)*.
- Romain implemented the compiler and the SECD machine.

## Usage.

- Compile with `make`.

- Run with `./fouine` to launch a REPL.

  By default, the REPL will interpret the parsed expressions using the `Interpreter` module.

  If `rlwrap` is installed on your machine, the REPL will maintain a history of your previous inputs, which you can access using the `↑` and `↓` keys.

- Use option `-machine` to instead compile the parsed expression to a custom SECD bytecode using the `Compiler` module, and then run that bytecode using the `Secd` module.

- Use option `-interm file` to store the generated bytecode to the given file in binary format.
- Use option `-from file` to run the bytecode stored in the given file in binary format.

- Add option `-debug` to get a pretty-printed version of the AST that was parsed, as well as the bytecode that was produced by the compiler *(when used in conjunction with the `-machine` option)*.

## Test suite.

The `tests/` directory contains a few code snippets which illustrate the capabilities of our implementation -- e.g. support of booleans, control flow operations, references, recursive functions or integer arrays.

## Code structure.

As usual, the source files for our modules are located inside the `src` folder, while all the build files generated by `ocamlbuild` are added to the `_build` folder: this way we don't mix up the two.

- The lexing and parsing of **fouine** expressions is handled by `ocamllex` and `ocamlyacc`, which are configured using files `lexer.mll` and `parser.mly`. Once parsed, the expressions have type `Ast.t`.
- The `Interpreter`, `Compiler` and `Secd` modules do just what you would expect.
- The `Bytecode` module contains a specification of the bytecode shared between our compiler and SECD machine.
- The `Beautify` module provides pretty-printing utilities for all types of values *(integers, arrays, functions, etc.)*.
- The `Print` module provides text formatting utilities.
- The `Nbe` module is an experimental implementation of **normalization by evaluation**, which is not fully ready yet.


# Implementation details.

## General design choices.

- We provide atomic types `unit`, `int`, `bool`, `array`, `'a ref`, `fun`.
- We support exceptions *(only on the interpreter for now)*.
- We only support arrays of integers *(because the assignment asked us to do so -- we could actually provide arrays of anything, even heterogeneous arrays)*.
- We support references to any of the previous atomic types, including functions.
- We have decided that the `:=` operator should return `unit` to stay consistent with OCaml.

### About builtin functions.

In order to provide a systematic -- and somewhat more elegant -- way of dealing with builtin functions, such as `prInt`, `aMake` or `ref`, we have decided to consider them just like any other function, so there are no special tokens for them.

Then, instead of starting to execute the code on an empty environment, we pre-load all those functions in the environment with the special type `MetaClosure`. This way, we can do something like:

```ocaml
let f = prInt in f 2;;
```
## Parsing.

### Currently supported syntax.

- A delimiter `;;` is **required** at the end of a given input.
- Any integer constants (including negative numbers).
- Boolean constants: `true` and `false`.
- Integer arithmetic: `*`, `+`, `-`, `/` and `mod`.
- Integer comparisons: `<`, `>`, `<=`, `>=`, `=`, `<>`.
- Boolean operations: `&&`, `||` and `not`.
- Named function declaration with multiple arguments with the `let` syntax.

  ```ocaml
  let f x y =
    x + 2 * y
  ```
- Anonymous function declaration with multiple arguments with the `fun` syntax.

  ```ocaml
  fun x y ->
    x + 2 * y
  ```
- Conditionnal statements: `if`, `then`, `else`.
  Note that, as in OCaml, a `else` branch is optional in which case a `unit` value is implied.

- Exception handling syntax: `try ... with E x -> ...`.
- Special `prInt` command to print integers, as well as `prOut` to print any type to standard out.
- Support for references: `ref 2`, `!x`, `x := 3`.
- Sequencing with `;`.
- Support for `int array` with `aMake` and the usual `arr.(i)` syntax.
- Chained function calls, even with anonymous functions.
- Scopes delimited by parens or `begin`, `end`.
- Support of several successive `let` statements without `;;` between them.
- **new!** : Full pattern matching in `let` bindings, function declarations and exceptions.

  ```ocaml
  >>> let (x, (y, z), _, 3) = (1, (2, 3), true, 3);;
  - : tuple = tuple
  >>> x;;
  - : int = 1
  >>> y;;
  - : int = 2;;
  ```

  ```ocaml
  >>> let f (x, y) = x * y;;
  >>> f (1, 2);;
  - : int = 2
  ```

  ```ocaml
  >>> try
        raise (1, 2)
      with E (x, y) ->
        x + y
      ;;
  - : int = 3
  ```

## REPL.

When running `./fouine` without additionnal parameters, we provide a REPL *(read-eval-print-loop)*, meaning that you can do the following:

```ocaml
>>> let a = 3;;
- : int = 3
>>> let b = 4;;
- : int = 4
>>> a + b;;
- : int = 7
```

Our pretty-printing routine is designed to be as explicit as possible. For instance:
```ocaml
>>> aMake 5;;
- : int array = [| 0; 0; 0; 0; 0 |]
```

```ocaml
>>> prInt;;
- : builtin = -
```

More interestingly, when dealing with partially evaluated functions, we substitute the already bound variables with their values:
```ocaml
>>> let f x y = x * y;;
- : fun = fun x -> fun y ->
    x * y
>>> f 2;;
- : fun = fun y -> 2 * y
```

## Interpretation.

We support the following:
- All arithmetical and boolean operations.
- Control flow (`if`, `else`).
- Variable definition and fetching through environments.
- Closures and variable propagation.
- Function calls, currying.
- Full reference support.
- Integer array support.
- Builtin functions on a metalanguage level (`prInt`, `prOut`, `aMake`).
- Successive `let` definitions without the `in` keyword with a persistent global environment.
- Recursion.
- Exceptions handling (using continuations).

## Compilation.

We support all of the above, except exceptions.

We use an extension of the SECD bytecode suggested in class, which has additionnal instructions to support conditonnal statements, recursive functions, arrays or references.

```ocaml
type bytecode =
  instruction list

and instruction
  = UnitConst
  | IntConst of int
  | BoolConst of bool
  | RefConst
  | Deref
  | ArrayConst
  | ArraySet
  | ArrayRead
  | UnOp of unary_op
  | BinOp of binary_op
  | Access of identifier
  | Encap of bytecode
  | Closure of identifier * bytecode
  | RecClosure of identifier * identifier * bytecode
  | Let of identifier
  | EndLet of identifier
  | Apply
  | Branch
  | Print
  | Return
```
